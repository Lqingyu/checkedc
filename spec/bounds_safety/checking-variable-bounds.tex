% !Tex root = checkedc.tex

\chapter{Bounds for expressions and bounds declaration checking}
\label{chapter:checking-bounds}

The prior chapter described how to declare bounds for variables.
This chapter describes how to infer a bounds expression for 
an expression based on the declare bounds.  An inferred bounds expression
describes the range of memory that can be accessed (if any) using 
the values produced by expression.  The inferred bounds expression
are used in runtime bounds checks.   This chapter also describes how to
 check that  declared bounds for variables are valid at initialization
 time and after assignments.

Bounds expressions for expressions are inferred using inference
rules.  The inference rules are defined by induction over expressions, 
the same way that typechecking rules work.  Given an expression
and bounds expressions for its subexpressions, a bounds expression
is constructed.  The induction base casses are variables (for which
bounds expressions are declared by the programmer) and constants.
The inference may reqiore tje cp,[o;er tp introduce temporaries to
hold the values of subexpressions.
Section~\ref{section:inferring-expression-bounds}
describes how to determine the bounds for an expression of type \arrayptr.
It does not cover operations that access data structures, such as member
access and pointer dereference. 
Those are covered in Chapters~\ref{chapter:structure-bounds} and 
\ref{chapter:pointers-to-data-with-arrayptrs}.

Bounds declarations are invariants about program variables
that must be checked at compile time.  The key idea is {\em subsumption checking}.
At \arrapyptr\ variable declarations and assignments, 
the right-hand side expression must have a bounds expression that includes (subsumes) 
the declared bounds  expression for the variable.  The memory that is accessible using
the right-hand side must include all the memory that is accessible via the variable.
In addition, after assignments to variables used in declared bounds, the
declared bounds must still be valid.

Subsumption checking is parameterized by {\it equality facts}.
An equality fact is a set of expressions or temporaries that evaluate 
to the same value given the current state of memory.  
Equality facts are introduced by assignments and are also inferred using dataflow analysis.

To handle both assignments to pointer variables with bounds and assignments
to variables used in bounds, we generalize bounds declaration
checking to operate over contexts.  Contexts are maps from variables
to bounds expressions for the values stored in the variables.  For
each top-level expression in a function, we start with a context based
on declared bounds.  We analyze the expression and produce a new
context that describes the bounds for variables after any assignments
in the expression have happened.  We then check that the bounds
expressions in the context subsume the declared bounds for variables.

The analysis of expressions is complicated by C's evaluation
rules for expressions.  C does not have a precise order of evaluation
for expressions.  The times at which assignments
must happen within expressions are only partially constrained.
C also allows allows control flow within 
expressions  via comma expressions,   conditional expressions, and
logical boolean expressions (the \code{&&} and \code{||} expressions).

To handle this, we extend the analysis to track assignments
whose stores to memory may pending.  For conditional expressions
and logical boolean expressions, we require that bounds be provably
true for the branches of the expressions. This rule keeps the analyis
tractable, while being easily explainable to programmers.  It disallows
some expressions for which bounds could be proved valid, such as 
a conditional expression whose evaluation is unordered with respect
to an assignment or another conditinal expression.

Section~\ref{section:checking-expression-statements} describes how
subsumption checking on bounds expressions.   The subsumption checking puts expressions
into a standard form.  It then uses syntactic equality, extended with
simple identities about C expressions and taking into account equality facts.
Inference steps for relational reasoning about bounds expressions 
are described in Chapter~\ref{chapter:simple-invariants}.

Section~ref{section:checking-assignment-expressions} 
covers the simple case where there is no control-flow
within an expression.
Section~\ref{section:checking-nested-assignment-expressions}
covers the more complex case where there is control-flow
within expressions.

To handle this, the expression analysis \var{A} takes as an input
an expression \var{E}, a context \var{C}, and a set of variables 
whose state is indeterminate beacuse they may have pending assignments \var{IV}. 
It produces as output a context \var{RC}, set of variables \var{RIV} whose
current state is indeterminate because they have pending assignments
assignments and a set of assignment expressions within the expression.
The analysis does a top-down traversal of the expression
tree with a case analysis for each expression based on the operator.
The analysis may recursively invoke itself:
\begin{enumerate}
\item The expression is a read of variable \var{V}. 
If \var{V} is in \var{IV}, this is an error.  This is undefined behavior according to the C specification,
because no ordering exists between the reads and a possible write.  The analysis $(C, IV, empty set)$
\item The expression is a literal expression or a constant.  It returns $(C, IV, empty set)$.
\item The expression is a parenthesized expression \var{E1}.  It return the result of $A(E1, C, IV)$.
\item The operator is not a control-flow operator:
For each subexpression \var{S_i}, we
\begin{enumerate}
\item We take all the assignments in other subexpressions and add them to a pending set \var{PS_i}.  
\item WE compute \var{(NP_i, NC_i, AS_i)} = $A(S_i, C, PS_i).
\end{enumerate}
We combine together thee contexts, the pending sets, the sets of assignments.  
To combine the contexts, we examine each context.  For any variable whoses bounds expression
differs from the original context, we select that bounds expression.  By the check in (2), at
most one context should contain an updated bounds expression for a variable.

While traversing the expression, we also determine the bounds expressions for any memory
accesses in the expression.  If we need to determine the bounds expression for a variable and
the variable is in the pending set, bounds(none) is used as the bounds.
If the resulting bounds expression uses a variable in the pending set, it is an error.
\end{enumerate} 
\item The operator is a comma operator of the form \code{e1, e2}.   We recursively
ivnoke{A} with code{e1}, context \var{C}, and the pending set{IV}.
invoke the analysis to compute a context and a list of assignments for \code{e1}.
For any variable that was not in the incoming pending set, but is 
pending in the incoming context, but that is now marked
as pending in the updated context, we clear the pending
information.
The expression analysis falls into two general categories
depending on whether the operator is a control-flow operator or
not.  If the operator is not a control-flow operator,
we set the pending flag in the context for any variables
assigned to by subexpressions.  We then compute updated contexts
for each of the subexpressions and merge the contexts.

 When we analyze an expression,
we check to see whether the expression operator is a control-flow
operator.   If it is not a control-flow operator, the evaluation
of expressions is unordered.  We set the pending flag for
any variables assigned to by subexpressions.
if the evaluation of the subexpressions is unordered (that is, the
expression operator is not a control-flow operator), we set the 
``pending'' flag for bounds expressions for ponter variables
that are assigned to within
``pending'' flag for bounds expression for pointer variables that
are modified or bounds expressions that use variables that are modified







Given an assignment \var{v}\lstinline+=+\var{e}, the effect of the assignment to \var{v}
is modelled by updating the context to contain bound expressions that are true
after the assignment.  If \var{v} has \arrayptr\ type, the bounds expression in
the context for \var{v} is updated to the inferred bounds expression for \var{e}.
We also model the change in \var{v}'s
value for any bounds expressions in the context that use \var{v}.   If the result of 
evaluating \var{e} is available in a temporary, we update the equality facts set 
to record that \var{v} equals the temporary when the (top-level) assignment
expression is completely evaluated.
We use the updated context and equality facts set to check
that the new bounds expressions subsume the declared bounds expressions for variables.

Section~\ref{section:checking-function-call-arguments}
describes validating function call arguments.

\section{Preparing a translation unit for checking}

To simplify the rules for checking, some syntactic transformations are done
on a translation unit before checking.  First, some syntactic cases are
replaced with semantically-equivalent cases.  This reduces the number of cases
that must be covered by the checking rules.  In-line return bounds expressions
are replaced with the form that uses a name for the return value. The form
\boundsdecl{\var{f}(\ldots{})}{\var{e1}} is changed to 
\texttt{\var{f}(\ldots{}) \keyword{where}
  \boundsdecl{\code{return_value}}{e1}}.
The \code{count} and
\code{byte_count} bounds expressions are also expanded to bounds expressions.
The form \boundsdecl{\var{x}}{\boundscount{\var{e1}}}
is replaced with \boundsdecl{\var{x}}{\bounds{\var{x}}{\var{x} \code{+} \var{e1}}}
and \boundsdecl{\var{x}}{\boundsbytecount{\var{e1}}}
is replaced with \boundsdecl{\var{x}}{\bounds{\cast{\arrayptrchar}{\var{x}}}
                                             {\cast{\arrayptrchar}{\var{x} \lstinline|+| \var{e1}}}}.
For now, we ignore the additional side conditions on count expressions. Checking of these
conditions will be addressed in Chapter~\ref{chapter:simple-invariants}.

Also, relative alignment is made explicit for all bounds
declarations: \boundsdecl{\var{x}}{\bounds{\var{e2}}{\var{e3}}} is expanded to
\boundsdecl{\var{x}}{\boundsrelval{\var{e2}}{\var{e3}}
                                  {\sizeof{\lstinline|typeof(|\var{x}\lstinline|)|}}}.
For code without explicit or implicit casts of \arrayptr s, relative
alignment can be ignored.

In the checking rules, sometimes shorter syntactic forms are used for
brevity. The shorter forms should be replaced with their full forms before
using the rules.

Second, lexical hiding of variables is eliminated by renaming variables so that
hiding no longer happens\footnote{Note that compilers typically do not need to
rename variables. Compilers already disambiguate variables with the
same name and the disambiguation mechanisms can be used in the implementation
of the checking rules.  For example, some compilers use distinct objects
to represent each variable declaration.}.  If a variable with block scope that does not
have external linkage has the same name as a variable with file scope or
a variable with an enclosing block scope, the variable
should be renamed to be distinct from other variables.  Similarly, parameter
variables that have the same name as a variable with file scope or a
variable with an enclosing block scope should be renamed.

\section{Inferring bounds expressions for expressions}
\label{section:inferring-expression-bounds}

We first discuss inferring bounds expressions for experssion. The bounds for an
expression is always determined with respect to a bounds
declaration context, wich maps variables to the declared bounds
expressions.  We will use $\vdash$ to denote the
valid bounds for an expression. The notation \boundsinfer{\var{e}}{\var{bounds-exp}}
means that expression \var{e} has valid bounds \var{bounds-exp}.

At times, we need to discuss bounds that are given in terms of the value
of an expression or a subexpression.   For example, a function call expression may
return an \arrayptr\ pointer to an array of constant size
\var{n}. The bounds for that pointer value would be (the
\arrayptr\ pointer, the \arrayptr\ pointer +
\var{n}). We use temporaries to denote the values
of expressions or subexpressions.   A temporary is a compiler-introduced
temporary variable that is initialized immediately upon evaluation of an
expression.   It differs from a source-level variable, whose assignment
may happen at some less-precisely specified time.   The evaluation of
expressions at runtime needs to store values in a temporary, 
if the temporary is used in a runtime
bounds check.

\subsection{Null pointers}

The bounds for 0 is the \lstinline|any| bounds:

\boundsinfer{0}{\boundsany}

\subsection{Variables}
\label{section:checking-variables}

Suppose there is a use of some variable \var{x}.

\begin{itemize}
\item
  If \var{x} has type \arrayptr, the bounds are the result of
  the analysis in Section~\ref{section:extent-definition}
  for this occurrence of \var{x}.
\item
  If \var{x} has type \ptrT, 
  \boundsinfer{\var{x}}{\boundsrel{\var{x}}{\var{x} \code{+ 1}}{\var{T}}}.
   On the right-hand side, \var{x} is reinterpreted as having \arrayptr\ type.
\item
  If \var{x} has an array type, the rules depend on whether \var{x}  is a parameter
  variable.  Typechecking in C treats a parameter variable with the type ``array of \var{T}''
   as though it has the type ``pointer to \var{T}''.   It does not enforce 
  at function calls that actual arguments have the required dimension size.  This means
  that the declared outermost bounds cannot be trusted for parameters with unchecked
  array types.  In contrast, local variables and externally-scoped variables are allocated 
  space for their declared types.  Declared dimension information for them can be trusted 
  regardless of whether they have checked or unchecked array types.  Checking of bounds 
  declarations for checked arrays  enforces that actual arguments meet the required
  dimension size.
\begin{itemize}
\item If 
\begin{itemize} 
\item \var{x} is a local variable or an externally scoped variable 
\item or \var{x} is a parameter variable with a checked array type
\end{itemize}
and \var{x} has a known number of elements \var{n}, then  
  \boundsinfer{\var{x}}{\boundscount{\var{n}}}.
\item Otherwise, the bounds are the result of the analysis in 
  Section~\ref{section:extent-definition} for this occurrence of \var{x}.
\end{itemize}
\item  Otherwise \var{x} has \boundsunknown.
\end{itemize}

\subsection{String literals and compound literal expressions}
A string literal \lstinline+''abc''+ evaluates to an lvalue with array type,
as does a compound literal of the form \lstinline+(int []) { 0, 1, 2, 3}+.
Thes lvalues are then converted implicitly to values with pointer type.

During bounds checking, a temporary is introduced for the result
of evaluating a string literal or compound literal expression.
If a literal \var{e} has array type with \var{n} elements, then
\boundsinfer{\var{e}}{\bounds{temporary for \var{e}}{temporary for \var{e} + \var{n}}}

\subsection{Address-of expressions}
\label{section:address-of-expression-bounds}

There are three kinds of address-of expressions:
\begin{itemize}
\item Address of a variable (\lstinline|&|\var{x}): a variable \var{x} with type \var{T} 
whose address is taken is considered to be an array of one element:

\boundsinfer{\lstinline|&|\var{x}}
            {\boundsrel{\lstinline|&|\var{x}}{\lstinline|&|\var{x} \lstinline| + 1|}{\var{T}}}.
            
\item Address of a pointer dereference operation (\lstinline|&*|\var{e}):
The address-of operation and the pointer dereference operation cancel. 
The bounds are the bounds of the underlying expression. 
If \boundsinfer{\var{e}}{\var{bounds-exp}}, then
\boundsinfer{\lstinline|&*|\var{e}}{\var{bounds-exp}}.

\item Address-of a subscripting expression (\lstinline|&|\var{e1}\lstinline|[|\var{e2}\lstinline|]|):
This is the same as taking the address of a pointer dereference operation.
According to the C semantics, \var{e1}\lstinline|[|\var{e2}\lstinline|]| is equivalent
to \lstinline|*(|\var{e1} \lstinline|+| \var{e2}\lstinline|)|.  If 
\boundsinfer{\var{e1} \lstinline|+| \var{e2}}{\var{bounds-exp}}, then
\boundsinfer{\lstinline|&|\var{e1}\lstinline|[|\var{e2}\lstinline|]|}{\var{bounds-exp}}.
\end{itemize}
   
\subsection{Funcrtion calls}
\label{section:inferring-bounds-for-function-calls}

Let \var{f} be the name of a function that returns an
\arrayptr\ value (pointers to functions will be handled later).
Suppose there is a function call expression of the form
\var{f}\code{(}\var{e1 \ldots{} en}\code{)}:

\begin{\boundsunknown}
\item
  If \var{f} has a bounds declaration for the return value of the form
  \code{return_value :} \var{exp1}, then

  \begin{itemize}
  \item
    Any arguments that correspond to formal parameters occurring in
    \var{exp1} must be valid non-modifying expressions. If they are
    not, \boundsinfer{\var{f}\lstinline|(|\var{e1} \ldots{} \var{en}\lstinline|)|}{\boundsunknown}.
  \item
    Otherwise, substitute \var{e1} \ldots{} \var{en} for the formal
    parameters of \var{f} occurring in \var{exp1}. Also substitute the
    special symbol \exprcurrentvalue\ for
    \code{return_value}. These substitutions produce \var{exp2}.
    \boundsinfer{\var{f}\lstinline|(|\var{e1} \ldots{} \var{en}\lstinline|)|}{\var{exp2}}.
  \end{itemize}
\item
  If \var{f} does not have a bounds declaration for its return value,
  then \boundsinfer{\var{f}\lstinline|(|\var{e1} \ldots{} \var{en}\lstinline|)|}{\boundsunknown}.
\end{\boundsunknown}

The special variable \lstinline|return_value| may appear in \var{exp1}. It
is the value of the function call expression. If \lstinline|return_value|
is used, a temporary variable is introduced to hold the result of the
function call.  The occurrencs of \lstinline|return_value| are replaced
with the the temporary variable.

There needs to be validation that the bounds for argument expressions
match the required bounds for formal parameters. This is described in
Section~\ref{section:checking-function-call-arguments}.

The following code provides examples of function call expressions where
bounds need to be computed. In the code, the programmer wraps a call to
\code{malloc} in an allocation helper, \code{alloc_helper}. The
function \code{alloc_helper} returns an \arrayptr\ value
that is passed as an argument to \code{init}, which initializes the array
and returns the \arrayptr\ value.
\begin{lstlisting}
array_ptr<int> alloc_helper(int n) : count(n)
{
    array_ptr<int> result : count(n) = malloc((sizeof(int) * n);
    return result;
}

array_ptr<int> init(array_ptr<int> target : count(s), 
                    int s) : count(s)
{
    for (int i = 0; i < count; i++) {
         target[i] = i;
    }

    return target;
}

void go(int size) 
{
    array_ptr<int> x : count(size) = init(alloc_helper(size), size);
    ...
}
\end{lstlisting}

First, syntactic forms for bounds expressions are expanded to eliminate
count expressions and in-line return expressions, as well as make
relative alignment explicit.

\begin{lstlisting}
array_ptr<int> alloc_helper(int n)
where return_value : bounds(return_value, return_value + n) rel_align(int)
{
    array_ptr<int> result : bounds(result, result + n) rel_align(int) =
      malloc((sizeof(int) * n);
    return result;
}

array_ptr<int> init(array_ptr<int> target : bounds(target, target + s)
                                            rel_align(int), 
                    int s) 
where return_value : bounds(return_value, return_value + s) rel_align(int)
{
    for (int i = 0; i < count; i++) {
      target[i] = i;
    }

    return target;
}

void go(int size) 
{
    array_ptr<int> x : bounds(x, x + size) rel_align(int) = 
        init(alloc_helper(size), size);
    ...
}
\end{lstlisting}

The valid bounds for the call to \lstinline|init(alloc_helper(size),size)| in
\lstinline|go| are computed using the return bounds for \lstinline|init|:

\begin{lstlisting}
    return_value : bounds(return_value, return_value + s) rel_align(int)
\end{lstlisting}

First, there is a check that all the actual arguments corresponding to
the formal parameters used by the return bounds expression are valid
non-modifying bounds expressions.   This check succeeds even though the
first actual argument \lstinline|alloc_helper(size)| is not a valid bounds
expression. The formal parameter \lstinline|target| is not used by the
return bounds expression.

Next, the actual arguments are substituted for the formal parameters and
a temporary \var{t1} is substituted for \lstinline|return_value|.
(\var{t1} is distinct from source-level variables).
The argument \lstinline|size| is substituted for \lstinline|s|, producing
\begin{lstlisting}[escapechar=\|]
    init(alloc_helper(size), size) |\(\vdash\)| bounds(|\var{t1}|, |\var{t1}| + size) rel_align(int)
\end{lstlisting}

% TODO: we can now introduce a temporary for the result of the function call, so this
% is confusing given the discussion below for alloc_helper, where we do that.
%   Checking of call arguments would fail due to the potential inequality
% of two function call expressions.  These issues should be explained in checking of function arguments.
%
%It would not be possible to represent the bounds if \lstinline|size| were a
%function call too:
%\begin{lstlisting}
%    array_ptr<int> x = init(alloc_helper(getsize()), getsize());
%\end{lstlisting}
%
%Function calls are not valid in bounds expressions:
%
%\begin{lstlisting}[escapechar=\|]
%   bounds(|\var{t1}|, |\var{t1}| + getsize())  // illegal
%\end{lstlisting}
%
%The solution would be to assign the result of \lstinline|getsize()| to a
%variable:
%\begin{lstlisting}
%   int tmp = getsize();
%   array_ptr<int> x = init(alloc_helper(tmp), tmp);
%\end{lstlisting}

The parameters to the call to \lstinline|init| need to be validated
(see Section~\ref{section:checking-function-call-arguments}). This
requires determining the valid bounds for \lstinline|alloc_helper(size)|. The
return bounds for \lstinline|alloc_helper| are used:
\begin{lstlisting}
   return_value : bounds(return_value, return_value + n) rel_align(int)
\end{lstlisting}

First, there is a check that the actual arguments that correspond to
formal parameters used in the return bounds are valid non-modifying
expressions. The only argument is the variable size, so this check
succeeds. Next, \lstinline|size| is substituted for \lstinline|n| and
a temporary variable \var{t2}is substituted for \lstinline|return_value|, producing:
\begin{lstlisting}[escapechar=\|]
   alloc_helper(size) |\(\vdash\)| bounds(|\var{t2}|, |\var{t2}| + size) rel_align(int)
\end{lstlisting}

\subsection{Pointer arithmetic}

The range of memory accessible through pointer arithmetic expressions
remains unchanged from the underlying pointer. In other words, for
\boundsinfer{\var{x}}{\var{bounds-exp}}, the bounds expression for any
pointer arithmetic involving \var{x} is the same as the one for
\var{x}. This is because that C semantics for pointer arithmetic is
that if \var{x} points to an object at runtime, any pointer arithmetic
involving \var{x} must produce a pointer to the same object. The bounds
of the object in memory are not changed by the pointer arithmetic.

We first cover the typical situation where the relative alignment type
for a pointer in a pointer operation matches the referent type of the
pointer. Given a pointer operation of the form \var{x op e1}, where [var{x}
has an \arrayptr\ type, \var{e1} has an integral type, and
\var{op} is addition or subtraction, the memory that can be accessed
through \var{x op e1} is the same memory that can be accessed through
\var{x}:

\begin{itemize}
\item
  If \var{x} is a pointer to \var{T} and 
  \boundsinfer{\var{x}}{\boundsrel{\var{e2}}{\var{e3}}{\var{T}}},
  then \boundsinfer{\var{x} \var{op} \var{e1}}{\boundsrel{\var{e2}}{\var{e3}}{\var{T}}}.
\end{itemize}

This can be extended to pointer operations of the form \var{e4 op e1},
where \var{e4} has type
\arrayptrT\ as
follows:

\begin{itemize}
\item
  If \var{e4} is a pointer to \var{T} and 
  \boundsinfer{\var{e4}}{\boundsrel{\var{e2}}{\var{e3}}{\var{T}}}
  then \boundsinfer{\var{e4 op e1}}{\boundsrel{\var{e2}}{\var{e3}}{\var{T}}}
\end{itemize}

Here is the full rule that handles the situation where the relative
alignment of the pointer differs from the size of the referent type of
the pointer. GCD computes the greatest common divisor of two integers.
The prior rules are just special cases of this rule:

\begin{quote}
If \var{e4} is a pointer to \var{T} and 
\boundsinfer{\var{e4}}
            {\boundsrel{\var{e2}}
                       {\var{e3}}
                       {\var{c}}}
then \boundsinfer{\var{e4 op e1}}
                 {\boundsrel{\var{e2}}
                            {\var{e3}}
                            {\texttt{GCD(\var{c}, \sizeof{\var{T}})}}}.
\end{quote}

\subsubsection{Pointer arithmetic for unchecked pointer types}

Pointer arithmetic involving an \arrayptr\ value checks that
the value is non-null and generates a runtime error if it is. This check
is important because a null pointer may have invalid bounds (this
follows from the definition of the meaning of bounds in 
Section~\ref{section:bounds-declarations}). It
prevents a null pointer that has invalid bounds from being used to create a
non-null pointer with valid bounds, which could then be used to access
memory.

Because the meaning of unchecked pointers has not changed, pointer
arithmetic involving a null unchecked pointer may not generate a runtime
error. The rules for array\_ptr pointer arithmetic can be applied to
unchecked pointer arithmetic, however, provided that a side condition that
the pointer expression is non-null is added:

\begin{quote}
If \var{e4} is a pointer to \var{T} and it can be proved that
\var{e4} \code{!= 0} and 
\boundsinfer{\var{e4}}{\boundsrel{\var{e2}}{\var{e3}}}{\var{c}}, then
\boundsinfer{\var{e4 op e1}}{\boundsrel{\var{e2}}{\var{e3}}
                                            {\texttt{GCD(\var{c},\sizeof{\var{T}})}}}.
\end{quote}

Chapter~\ref{chapter:simple-invariants}
provides a general framework for checking side-conditions as
part of checking bounds declarations.

\subsection{Cast expressions}
\label{section:cast-expressions}

Given a cast expression of the form \cast{\var{T}}{\var{e}},
the bounds for \var{e} are determined. The bounds for
\var{e} are used as the bounds for the entire expression.
  
\subsection{Conditional expressions}

Given an expression of the form \var{e1} \code{?} \var{e2}
\code{:} \var{e3}, the bounds for \var{e2} and \var{e3} are
determined. They must be syntactically identical (after putting the
bounds into a normal form). The bounds for \var{e2} are used as the
bounds for the entire expression.

\emph{This is an expression where a conditional bounds expression could
be used to represent the resulting range.  Another alternative that works
with current syntax would be to create upper/lower-bound expressions
that use e1 such as (e1 ? lower-bound(e2) : lower-bound(e3), e1 ?
upper-bound(e2) : upper-bound(e3). For now, we defer discussion of both
alternatives. }

\subsection{Comma expressions}

Given an expression of the form \var{e1} \code{,} \var{e2}, the
bounds for \var{e2} are determined. The bounds for \var{e2} are used
as the bounds for the entire expression.  

\subsection{Assignment expressions}

Given an expression of the form \var{e1} \code{ = } \var{e2}, the
bounds for \var{e2} are determined. The bounds for \var{e2} are used
as the bounds for the entire expression.

Note that if \var{e1} is a variable,
there is an order of evaluation issue of \var{e1} appears in the bounds for
\var{e2}.   Specifically, the bounds for \var{e2} cannot be used to
check a memory access within the top-level expression being evaluated.

\section{Bounds declaration checking for simple assignment expressions}
\label{section:checking-assignment-expressions}

For an assignment expression of the form \var{x} \code{=} \var{e},
where \var{x} is a variable and \var{e} is an expression, there are
three aspects to to computing bounds.   First, we infer the
bounds expression for \var{e}.

Second, we determine the effect of the assignment on the
bounds declaration context.
We start with the context that is true before the expression
is evaluated and determine the context that is true after
the expression is evaluated.

This seems straightforward.  If \var{x} has type
\arrayptr, use the computed bounds for \var{e} to update the context
so that the bounds for \var{x} are the bounds of \var{e}.
However, there is a problem. The bounds for \var{e} is determined
\var{before} \var{x} changes value. When \var{x} changes value, the bounds
for \var{e} may no longer be true if \var{x} appears in the bounds.
The context could contain uses of \var{x} also in bounds expressions.

A simple solution is to invalidate bounds expressions where \var{x} appears in
the bounds. This does not work well when a variable that appears in its
own bounds declaration is incremented or decremented. Consider the
following example:
\begin{lstlisting}
array_ptr<int> x : bounds(x, high) = ...
int sum = 0;
while (x < high) {
    sum += *x;
    x++;  // bounds for x would be undefined for the simple solution
}
\end{lstlisting}

A possible solution is to require programmers to copy variables in loops
that are modified using only pointer arithmetic to temporary variables
before the loop. The temporary variables could then be used in bounds.
However, this might increase register pressure and worsen performance.

One can do better than that for loop induction variables, which are
variables that are incremented or decremented by a constant in a loop.
Condit \textit{et al.} observe that some assignment expressions are
invertible: the old value of a variable can be calculated from the new
value . One can update the bounds by substituting the inverted
expression in place of the variable. The updated bounds can then be
narrowed to satisfy loop bounds invariants. Invertible expressions
include the addition and subtraction expressions that update loop
induction variables.

The updated context is determined in two steps. First, if
\var{x} has type \arrayptr, the context is updated for
\var{x} using bounds expressions that use the \emph{old} value of \var{x}:

\begin{\boundsunknown}
\item
  If \boundsinfer{\var{e}}{\var{exp}}, then the context is updated with
  \boundsdecl{\var{x}}{\var{exp}}.
\item
  Otherwise, the context is updated with \boundsdecl{\var{x}}{\boundsunknown}
   to indicate that \var{x} has no valid bounds.
\end{\boundsunknown}

Second, the context is updated to reflect the change in the value of
\var{x}:

\begin{itemize}
\item
  If the expression being assigned is invertible, the right-hand side of
  any bounds expression that uses \var{x} will be updated to use an
  expression that inverts the new value to compute the old value.
\item
  Otherwise, any bounds expression that involves \var{x} is invalidated
\end{itemize}

Third, if the value of \var{e} is also available in a temporary,
we record in the set of equality facts that \var{x} equals that
temporary (at the end of evaluating the expression).

\subsection{Invertibility}

The following examples illustrate invertibility and updating bounds. For
the first example, suppose there is a declaration of an
\arrayptr\ variable followed by a decrement of a variable
involved in the bounds:

\begin{lstlisting}
array_ptr<int> a : count(len) = ...
len = len - 1
\end{lstlisting}

The original value of \lstinline|len| can be computed from the new value.
In this case, a valid new bounds after the decrement of \lstinline|len| is
\lstinline|count(a)  == len + 1.| The bounds for \lstinline|a| after the
assignment are:
\begin{lstlisting}
len = len - 1
where a : count(len + 1);
\end{lstlisting}

For the second example, consider an update to a pointer variable that
appears in its own bounds:
\begin{lstlisting}
array_ptr<int> p : bounds(p, high) = ...         
while (p < high) {
    ...
          p = p + 1;
}
\end{lstlisting}

First, the new bounds expression for the expression \lstinline|p + 1| is
computed. It is the same as the original bounds expression
\lstinline|bounds(p, high)|. Because \code{p} is modified by the assignment, the
inverted expression for \lstinline|p + 1| is substituted into
\lstinline|(p, high)|. The inverted expression for \lstinline|p + 1| is \lstinline|p - 1|.
This leads to bounds of the form \lstinline|bounds(p - 1, high)|:

\begin{lstlisting}
while (p < high) {
    ...
          p = p + 1 where p : bounds(p - 1, high);
}
\end{lstlisting}

Bounds validity is preserved when the range of a bounds expression is
narrowed. \lstinline|(p - 1, high)| implies that \lstinline|(p, high)| is a
valid bounds expression. This reestablishes the loop bounds invariant
for \lstinline|p| of \lstinline|(p, high)|.

\begin{lstlisting}
while (p < high) {
    ...
          p = p + 1 where p : bounds(p, high);
}
\end{lstlisting}

The correctness of narrowing depends on pointer arithmetic overflow
for checked pointer types being a runtime error. For a lower bound \var{e1} in a bounds
expression, we can only substitute \var{e2} for \var{e1} as the lower
bound if \var{e2} \code{>=} \var{e1}. The identity \code{p > p - 1} 
holds only if overflow is a runtime error.

\subsection{Invertible expressions}
An expression is invertible with respect to a variable \var{x} if:

\begin{\boundsunknown}
\item
  The expression is \var{x}
\item
  or

  \begin{\boundsunknown}
  \item
    The operator in the expression is an addition, subtraction, one's
    complement, unary minus, unary plus, exclusive-or, a bit-preserving
    cast operator, or a widening cast operator, and
  \item
    The variable \var{x} occurs only in one argument of the operation and that
    argument is an invertible expression with respect to \var{x}
  \item
    Any other argument of the operation is a non-modifying expression,
    excluding non-modifying expressions that are or include member
    references, indirect member references, or pointer dereferences.
  \end{\boundsunknown}
\end{\boundsunknown}

The addition and subtraction operations must be for checked pointer
arithmetic or unsigned integer arithmetic. An implementation may allow
integral addition and subtraction operations to be invertible if
integral addition and subtraction are defined as two's complement
arithmetic where extra bits are discarded on overflow. However, this
introduces the possibility of non-portable code.

Given the expression \var{x} \code{=} \var{e}, where \var{x} occurs once
in \var{e}, mathematical rules are applied to solve for \var{x} in
\var{e}. We generalize the left-hand side from \var{x} to an expression
\var{f} and define \texttt{inverse(}\var{f}\texttt{,}
\var{e}\texttt{)} as follows:

\begin{longtable}[c]{@{}ll@{}}
\toprule
Given \texttt{inverse(\var{f}, \var{e})}, where & the result is:\tabularnewline
\midrule
\endhead
\var{e} = \texttt{x} & \var{f}\tabularnewline
\var{e} = \code{\~}\var{e1} &
\texttt{inverse(\code{\~}\var{f}, \var{e1})}\tabularnewline
\var{e} = \code{-}\var{e1} & \texttt{inverse(\code{-}\var{f}, \var{e1})}\tabularnewline
\var{e} = \code{+}\var{e1} & \texttt{inverse(\code{+}\var{f}, \var{e1})}\tabularnewline
\var{e} = \cast{\var{t1}}{\var{e1}}, where \var{e1} has
type \var{t2} & \texttt{inverse(\cast{\var{t2}}{\var{f}},
\var{e1})}\tabularnewline
and \code{(}\var{t1}\code{)} is not a narrowing cast & \\
\var{e} = \var{e1} \code{+} \var{e2}, where \texttt{x} occurs in
\var{e1} & \texttt{inverse(}\var{f} \code{-} \var{e2},
e1)\tabularnewline
\var{e} = \var{e1} \code{+} \var{e2}, where \texttt{x} occurs in
\var{e2} & \texttt{inverse(}\var{f} \code{-} \var{e1},
\var{e2})\tabularnewline
\var{e} = \var{e1} \code{-} \var{e2}, where \texttt{x} occurs in
\var{e1} & \texttt{inverse(}\var{f} \code{+} \var{e2},
\var{e1})\tabularnewline
\var{e} = \var{e1} \code{-} \var{e2}, where \texttt{x} occurs in
\var{e2} & \texttt{inverse(}\var{e1} \code{-} \var{f},
\var{e2})\tabularnewline
&\tabularnewline
\var{e} = \var{e1} \code{^} \var{e2}, where \texttt{x} occurs in
\var{e1} & \texttt{inverse(}\var{f} \code{^} \var{e2},
\var{e1})\tabularnewline
\var{e} = \var{e1} \code{^} \var{e2}, where \texttt{x} occurs in
\var{e2} & \texttt{inverse(}\var{f} \code{^} \var{e1},
\var{e2})\tabularnewline
\bottomrule
\end{longtable}

Given \texttt{inverse(x}, \var{e}), the rules are applied repeatedly
until the original value of x in e has been computed. Here is an example
of computing the inverse of \code{x = (x + 4) + 5}:
\begin{lstlisting}
   inverse(x, (x + 4) + 5) =
       inverse(x - 5, x + 4) =
          inverse((x - 5) - 4, x) =
              (x - 5) - 4
\end{lstlisting}

\section{Bounds for expressions with nested assignment expressions}
\label{section:checking-nested-assignment-expressions}

C allows assignment expressions to be nested within other expressions.
This means that the approach of 
Section~\ref{section:checking-assignment-expressions} has to be extended to walk
expressions recursively and update the context during the walk.

The C specification states that multiple assignments to the same scalar variables within an expression
result in undefined behavior \cite[Section 6.5]{ISO2011} when the order of evaluation is not specified.
Similarly, assigning a variable and reading from it within an expression is also undefined behavior
when the order of evaluation is not specified.  With the restriction
on nested assignments, it is straightforward to check for undefined behavior involving
variables used in bounds: gather all the assignments in an expression to variables used
by in-scope bounds declarations and construct the ``sequenced before'' ordering described in 
\cite[Section 5.1.2.3]{ISO2011}.    If some pair of assignments is not ordered, the program is rejected
as having undefined behavior with respect bounds.   
% For an operator that does a bound check,
% we also check that for any variables used by that bounds check, any assignments to those
% variables are ordered with respect to that operation.

However, we do have to deal with sequential control-flow
within expressions.   We model this by having a {\em bounds declaration
context} that we track and update during expression evaluation. 
The bounds declaration context is a mapping from variables to 
their bounds declarations.   We also have an {\em equality facts set}.   This is a set of sets
of expressions that are known to be equal.   We traverse the assignment expressions in a top-level
expression in any order legal under the the ``sequenced before'' ordering and update the context
and equality facts as assignments occur.  It is possible for variables not occuring in a 
bounds declaration to be swept up by this analysis.   If there is an assignment to such
a variable, it could cause a problem because the assignment might happen anytime during evaluation
of the top-level expression.     If the assignment is not ordered with respect to all other
assignments in the expression, we discard any equality facts that use the variable and mark any
bounds declaration that use the variable as unknown.

Given some expression \var{e} that has subexpressions \var{e}\textsubscript{1}
\ldots{}. \var{e}\textsubscript{n}, start with the context for \var{e}. Compute a
new context and the bounds expression for \var{e} as follows:

\begin{itemize}
\item
  Traverse \var{e}\textsubscript{1} \ldots{} \var{e}\textsubscript{n} in an order
  that respect the sequence points of \cite{ISO2011}. For each subexpression, take the
  context and compute the updated context and the bounds expression (if
  any) for the subexpression.
\item
  If \var{e} is an assignment expression, 
  apply the rules in Section~\ref{section:checking-assignment-expressions} to
  compute an updated context and a bounds expression for \var{e}
\item
  Otherwise, apply the rules in Section~\ref{section:inferring-expression-bounds}
  to compute an updated bounds expression for \var{e}.
\end{itemize}

\section{Expression statements}
\label{section:checking-expression-statements}

Expression statements need to be checked for consistency with their
expected bounds declarations. If an expression statement is within a
bundled block, the checking is deferred to the end of the bundled block.

To check an expression statement, the analysis of 
Section~\ref{section:extent-definition} is used
to determine the context for the expression in the statement (the bounds
for variables before the statement is evaluated). The rules in 
Section~\ref{section:checking-nested-assignment-expressions}
are then used to determine the updated context.

The updated context is then checked against the bounds declarations that
must be true after the expression statement. For each
\arrayptr\ variable \var{x} in scope, the expected bounds is
computed:

\begin{itemize}
\item
  If the expression statement has a bounds declaration for \var{x}, the
  bounds expression in that bounds declaration is used.
\item
  Otherwise, the analysis of Section~\ref{section:extent-definition}
  is used to determine the
  expected bounds expression for x.
\end{itemize}

We will refer to the bounds expression for \var{x} in the updated context
as the updated bounds expression.  It must imply that the
expected bounds expression holds. Implication is checked in this section
using by placing non-modifying expressions into a canonical form and
checking for syntactic equality. If two expressions have the same
canonical form, any values that they have at runtime will always be
identical. Chapter~\ref{chapter:simple-invariants}
describes more general techniques for checking
that context bounds imply the expected bounds.

The updated bounds expression implies that the expected bounds
expression holds if:

\begin{itemize}
\item
  The expected bounds expression is \boundsunknown, or
\item
  The updated bounds expression is \boundsany, or
\item
  The updated bounds expression and the expected bounds expression are
  equal syntactically after placing the expressions into canonical
  forms,
\item
  The canonicalized expressions
  differ syntactically only in their relative alignment, and
  the context bounds implies the expected relative alignment \var{c}.
  This is true if:

  \begin{itemize}
  \item
    The context relative alignment is an integer multiple of the
    expected relative alignment,
  \item
   or given a context bounds expression of the form
   \boundsrel{\var{e1}}{\var{e2}}{\var{d}},
   \texttt{(\cast{\arrayptrchar}{\var{x}} - \cast{\arrayptrchar}{\var{e1}}) \% \var{c}}
   canonicalizes to \code{0}, as does
   \texttt{(\cast{\arrayptrchar}{\var{e2}} - \cast{\arrayptrchar}{\var{x}}) \% \var{c}}.
  \end{itemize}
\end{itemize}

\subsection{Canonicalization of expressions in bounds expressions}
\label{section:canonicalization}

Most readers can skip this section safely and come back to it as
necessary. This section is for compiler implementers and for programmers
who want to understand when expressions are regarded as identical by
canonicalization.

Canonicalization guarantees the following: if two non-modifying
expressions have the same canonical form and if they produce values when
evaluated at runtime, the two values will be equal. There are two
important things to understand about this definition. First, two C
expressions may have different canonicalized forms and still always
produce the same value at runtime (in the terminology of logic,
canonicalization is incomplete). Second, canonicalization does not
guarantee that an expression will actually produce a value at runtime.
It may still have a runtime fault. The runtime correctness of bounds
expressions is implied by transitivity: a bounds expression must be
implied by another bounds expression, and so on, until a bounds
expression is implied by an allocation. The allocation must have
involved an expression that actually produced a value.

This has a surprising consequence: integer arithmetic operations that
check for overflow can be regarded as following mathematical rules
during canonicalization. A compiler could not reassociate \texttt{((a
\plusovf\ b) \plusovf\ c)} to \texttt{(a
\plusovf\ (b \plusovf\ c)} and replace the first
expression with the second one because it could cause an overflow where
none occurred before. For canonicalization, though, reassociation is
fine.

Signed integer operations do not follow certain mathematical identities.
This is because according to the rules in 
Section~\ref{section:changes-to-undefined-behavior}, they may produce
a value on overflow, but the properties of the value are not specified.
Signed addition is not associative: \code{(a + b) + c} is not
guaranteed to produce the same result as \code{a + (b + c)} in the
presence of overflow. The expression \code{a + b} may overflow, while
\code{b + c} may not overflow or the reverse may occur. In addition,
for signed integers, it is not guaranteed that \code{a - b} =
\code{a + (-b)} or that \code{-(-(a))} = \code{a}.

The canonicalization rules need to disambiguate between signed and
unsigned operators for integers, as well as operators that check for
overflow. All integer operators will be subscripted by whether they
apply to signed or unsigned integers and whether they check overflow 
using the subscripts \code{signed}, \code{unsigned}, and
\code{ovf}. For example, the expression \code{(a + b) + c} involving
signed integers will be written as \texttt{(a
+}\emph{\textsubscript{signed}} \texttt{b)
+}\emph{\textsubscript{signed}} \texttt{c}.

The overflow checking operators introduced in
Section~\ref{section:pointers-as-integers} only include
operators that can occur in practice. For canonicalization, it is useful
to have a complete set of operators, including
\plusovf\ and \minusovf\ that
take two integers (both signed or unsigned) and produce an integer that
has the same type as the arguments, as well as unary negation that takes
a signed or unsigned integer and produces a signed integer.

In the rules for canoncialization, when a subscript on an integer
operator is omitted, the rule applies to all forms of the operator.
Sometimes the subscript \var{kind} will be used on operators. Either
\code{unsigned} or \code{ovf} should be substituted for \var{kind}
in the rule.

The first step in canonicalization is to convert non-modifying
expressions to an initial representation:

\begin{compactenum}
\item
  All expressions involving operators are fully parenthesized and
  unnecessary parenthesis on variables and constants are removed. For
  example, \var{e1} \var{op1} \var{e2} \var{op2} \var{e3}, is
  replaced by \texttt{((}\var{e1} \var{op1} \var{e2}\texttt{)}
  \var{op2} \var{e3}\texttt{)} or \texttt{(}\var{e1} \var{op1}
  \texttt{(}\var{e2} \var{op2} \var{e3}\texttt{))}, depending on the
  precedence of \var{op1} and \var{op2}.
\item
  Implicit cast operations are made explicit.
\item
  The pointer dereference \code{*} and pointer indirection operators
  \code{(->)} are implicitly annotated with their pointer types.
  This is necessary because converting pointer arithmetic to integer
  arithmetic will erase the type information needed by these operators.
\item
  Unary plus operations are removed.
\item
  Array references of the form
  \var{e1}\code{[}\var{e2}\code{]} are converted to
  \code{*((}\var{e1}\code{)} \code{+}
  \code{(}\var{e2}\code{))}
\item
  Pointer arithmetic is expanded to integer-based arithmetic.
\item
  Binary subtraction expressions are canonicalized to use unary minus
  when possible: \var{e1} \code{-}\emph{\textsubscript{kind}}
  \var{e2} is converted to \var{e1}
  \code{+}\emph{\textsubscript{kind}}
  \code{-}\emph{\textsubscript{kind} e2}.
\end{compactenum}

For the second step of canonicalization, two sets of binary arithmetic
operators are defined

\begin{compactitem}
\item
  The set of commutative and associative operators (CA operators).
  This includes:

  \begin{itemize}
  \item
    The operators +\texttt{\textsubscript{unsigned}},
    \texttt{*\textsubscript{unsigned}}, \plusovf\,
    and \mulovf\.
  item
    The bitwise operators \lstinline@|@, \code{&}, and
    \code{^}.
  \item
    The Boolean operators \lstinline@||@ and \code{&&}.
  \end{itemize}
\item
  The set of commutative-only operators (CO):
  \texttt{+\textsubscript{signed}} and \texttt{*\textsubscript{signed}}.
\end{compactitem}

The following rules are applied until no further changes occur:

\begin{compactenum}
\item
  Removing pointer casts and identity casts on integral types (casts
  from a type to itself). Pointer casts do not change the values of
  pointers.
\item
  Folding constant integral expressions. The following expressions are
  constant-folded:

  \begin{compactenum}
  \item
    Any constant expression that uses only overflow-checking arithmetic
    operators and that mathematically evaluates to an in-range integer
    value. The value is the mathematical result.
  \item
    Any constant expression involving integers that produces a defined
    result according to the C language standard or the C implementation
    rules.
  \end{compactenum}
\item
  Applying algebraic identities to simplify expressions

  \begin{compactenum}
  \item
    Arithmetic identities

    \begin{compactenum}
    \item
      \var{e} \code{+ 0 =} \var{e}, \var{e} \code{- 0 =} \var{e}, 
      \code{0 -} \var{e} =
      \code{(-}\var{e}\code{)}, \code{0 *} \var{e} = \code{0}, 
      \code{1 *} \var{e} = \var{e}, 
      \var{e} \code{/ 1} = \var{e},
      \var{e} \code{/ -1} = \code{-}\var{e},
      \var{e} \lstinline|% 1| = \var{e}
    \item
      For a positive constant \var{c}, (\var{e}
      \code{*}\emph{\textsubscript{kind}} \var{c}) \lstinline|%|
      \var{c} = \code{0}
    \end{compactenum}
  \item
    Bitwise identities: \var{e} \code{&} \code{0} = \code{0},
    \var{e} \lstinline@|@ \code{0} = \var{e}, \var{e}
    \lstinline|^| \code{0} = \var{e}, and
    \lstinline|~(~|\var{e}|\lstinline|))| =
    \var{e}
  \item
    Boolean identities: given a non-zero constant c, \var{e}
    \code{&&} \var{c} simplifies to \var{e}, \var{e}
    \lstinline@||@ \var{c} simplifies to \code{1}, and
    \code{!}\var{c} = \emph{0}. When \var{c} = \code{0}, \var{e}
    \code{&&} \var{c} simplifies to \code{0}, \var{e}
    \lstinline@||@ \var{c} simplifies to \var{e}, and
    \code{!}\var{c} = \code{1}.
  \item
    Double negation:
    \code{-}\emph{\textsubscript{kind}}(\code{-}\emph{\textsubscript{kind}}
    \var{e}\code{)} = e.
  \item
    Cancelling terms: \var{e} \code{-}\textsubscript{signed} \var{e}
    simplifies to \code{0} and \var{e} \texttt{+\textsubscript{kind}}
    (\texttt{-\textsubscript{kind}} \var{e}) simplifies to \code{0}.
    This is applied more generally to a sequence of addition operations
    of the form \texttt{(}\ldots{} \texttt{(}e1
    \texttt{+}\textsubscript{kind} e2\texttt{)} \ldots{}
    \texttt{+}\textsubscript{kind} \texttt{-}\emph{\textsubscript{kind}}
    e1 \ldots{}\texttt{)}.

    When identities have commutative versions, those are applied as
    well.
  \end{compactenum}
\item
  Applying associativity commutivity, and distributivity rules to put
  expressions in canonical forms:
\begin{compactenum}
\item
  For each operator \var{op} in CA, repeatedly rewriting any expression
  of the from \var{e1} \var{op} \code{(}\var{e2} \var{op}
  \var{e3}\code{)} to \code{(}\var{e1} \var{op}
  \var{e2}\code{)} \var{op} \var{e3} until no further rewrites are
  possible.
\item
  For each operator \var{op} in CA, for each sequence of operations
  (\ldots{} ((\var{e1} \var{op} \var{e2}) \var{op} \var{e3})
  \ldots{} \var{op} \var{en}), reordering the operands so that
  \var{e1} \ldots{} \var{en} appear in lexicographic order. Constants
  should appear lower in the lexicographic order than more complex
  expressions.
\item
  For each operator \var{op} in CO, commuting the operands in \var{e1}
  \var{op} \var{e2} so that \var{e1} is lower in the lexicographic
  order.
\item
  Applying the following distributivity rules:

  \begin{compactenum}
  \item
    Rewriting \code{-}\emph{\textsubscript{kind}}\code{(}\var{e1}
    \code{+}\emph{\textsubscript{kind}} \var{e2}\code{)} to
    \code{(-}\emph{\textsubscript{kind} e1}\code{)} \code{+}
    \code{(-}\emph{\textsubscript{kind} e2}\code{)},
  \item
    Rewriting \code{(}\var{e1} \code{+}\emph{\textsubscript{kind}}
    \var{e2}\code{)} \code{*}\emph{\textsubscript{kind}} \var{e3}
    to \code{(}\var{e1} \code{*}\emph{\textsubscript{kind}}
    \var{e3}\code{)} \code{+}\emph{\textsubscript{kind}}
    \code{(}\var{e2} \code{*}\emph{\textsubscript{kind}}
    \var{e3}\code{)}
  \item
    Rewriting \code{(}\var{e1} \lstinline@|@ \var{e2}\code{)} \lstinline@&@ \var{e3} as 
    \code{(}\var{e1} \lstinline@&@ \var{e3}\code{)} \lstinline@|@ \code{(}\var{e2} 
    \lstinline@&@ \var{e3}\code{)} and
    rewriting \var{e3} \lstinline@&@ \code{(}\var{e1} \lstinline@|@ \var{e2}\code{)} as 
    \code{(}\var{e3} \lstinline@&@ \var{e1} \lstinline@|@ \var{e3} \lstinline@&@ \var{e2}\code{)}
  \item
    Rewriting !(\var{e1} \lstinline@||@ \var{e2}) as ((!\var{e1}) \lstinline@&&@ (!\var{e2})) and
    !(\var{e1} \lstinline@&&@ \var{e2}) as ((!\var{e1}) \lstinline@||@ (!\var{e2}))
  \item
    Rewriting (\var{e1} \lstinline@||@ \var{e2}) \lstinline@&&@ \var{e3} as 
    (\var{e1} \lstinline@&&@ \var{e3})
    \lstinline@||@ (\var{e2} \lstinline@&&@ \var{e3}) and rewriting \var{e3} \lstinline@&&@ (\var{e1}
    \lstinline@||@ \var{e2}) as (\var{e3} \lstinline@&&@ \var{e1} \lstinline@||@ \var{e3} 
    \lstinline@&&@ \var{e2})
  \end{compactenum}
\end{compactenum}
\end{compactenum}

The distributivity rules expand the size of expressions, potentially
increasing size exponentially. Implementations may have a reasonable
limit on the size of canonicalized expressions. A minimum required limit
will be determined based on an empirical evaluation of C programs.

\subsection{An example of canonicalization}
\label{section:canonicalization-example}

Here is how bounds for the following declaration and statement will be checked:
\begin{lstlisting}
array_ptr<int> x;
x = malloc(sizeof(int)*5) where x : count(5);
\end{lstlisting}

The function \lstinline+malloc+ is assumed to have the bounds declaration:

\begin{lstlisting}
array_ptr<void> malloc(size_t num) : byte_count(num);
\end{lstlisting}

even though in practice it will have a bounds-safe interface that does
not use a checked pointer type.

First, the implicit casts are made explicit and count is expanded to bounds:

\begin{lstlisting}
x = (array_ptr<int>) malloc(sizeof(int)*(size_t) 5) where x : bounds(x, x + 5);
\end{lstlisting}

Next, the bounds for the right-hand expression are computed. The bounds
declaration for malloc is expanded to:
\begin{lstlisting}
array_ptr<void> malloc(size_t num)  
where return_value : bounds((array_ptr<char>) return_value, 
                            (array_ptr<char>) return_value + num)
\end{lstlisting}

The bounds for malloc are used to compute the bounds for the function
call \lstinline+malloc(sizeof(int)*(size_t) 5)+. The actual argument
\lstinline+sizeof(int)*(size_t) 5+ is substituted for \lstinline+num+ in the
bounds expression for the return value of \lstinline+malloc+:
\begin{lstlisting}
return_value : bounds((array_ptr<char>) return_value, 
                      (array_ptr<char>) return_value + sizeof(int)*(size_t) 5)
\end{lstlisting}

Next, \lstinline+expr_current_value+ is substituted for \lstinline+return_value+ :
\begin{lstlisting}
expr_current_value :
  bounds((array_ptr<char>) expr_current_value,
         (array_ptr<char>) expr_current_value + sizeof(int)*(size_t) 5)
\end{lstlisting}

Then, the bounds for \lstinline|(array_ptr<int>) malloc(sizeof(int)*(size_t) 5)|
are computed. The inverse cast \lstinline|(array_ptr<void> expr_current_value)|
is substituted for \lstinline|expr_current_value|:

\begin{lstlisting}
expr_current_value :
  bounds((array_ptr<char>) ((array_ptr<void>) expr_current_value),
         (array_ptr<char>) ((array_ptr<void>) expr_current_value) +
                               sizeof(int) * (size_t) 5)
\end{lstlisting}

Finally, \lstinline|x| is substituted for \lstinline|expr_current_value| :

\begin{lstlisting}
x : bounds((array_ptr<char>) ((array_ptr<void>) x), 
           (array_ptr<char>) ((array_ptr<void>) x) +
                                sizeof(int) * (size_t) 5)
\end{lstlisting}

Now, it has be shown that the computed bounds for \lstinline|x|\ imply the expected
bounds for \lstinline|x|\ of \lstinline|bounds(x, x + 5)|. The bounds expressions are both
converted to use integer arithmetic:

\begin{lstlisting}[escapechar=\@]
// computed bounds
bounds((array_ptr<char>) ((array_ptr<void>) x),
       (array_ptr<char>) ((array_ptr<void>) x) @+\textsubscript{ovf}@
                             sizeof(int)@*\textsubscript{unsigned}@(size_t) 5))
// expected bounds
bounds(x, x @+\textsubscript{ovf}@ (5 @*\textsubscript{ovf}@(signed_size_t) sizeof(int)))
\end{lstlisting}

Next, unnecessary pointer casts are removed:
\begin{lstlisting}[escapechar=\@]
// computed bounds
bounds(x, x @+\textsubscript{ovf}@ (sizeof(int) @*\textsubscript{unsigned}@ (size_t) 5))
// expected bounds
bounds(x, x @+\textsubscript{ovf}@ (5 @*\textsubscript{ovf}@ (signed_size_t) sizeof(int)))
\end{lstlisting}

After that, constant folding is done. If \lstinline+sizeof(int)+ is 4, the result is:
\begin{lstlisting}[escapechar=\@]
// computed bounds
bounds(x, x @+\textsubscript{ovf}@ 20)
// expected bounds
bounds(x, x @+\textsubscript{ovf}@ 20)
\end{lstlisting}

We must also show the expected bounds imply that the 
\lstinline|rel_align(int)| requirement is met. This is straightforward for
a constant-sized array. It involves showing given the variable \lstinline+x+ with
\bounds{\var{e1}}{\var{e2}} that
\lstinline[mathescape]|((array_ptr<char>) x - (array_ptr<char>) $\var{e1}$) % 4| canonicalizes
to 0, as does \lstinline[mathescape]|((array_ptr<char> $\var{e2}$ - (array_ptr<char>) x) \% 4|.

For the first expression, \lstinline|((array_ptr<char>) x - (array_ptr<char>) x) % 4|
simplifies to \lstinline|0 % 4|, which constant-folds to \lstinline|0|.
For the second expression, \lstinline|((array_ptr<char>) (x + 5) - (array_ptr<char>) x) % 4|
simplifies to
\lstinline[mathescape]|((x $\texttt{+}\textsubscript{ovf}$ 20) $\texttt{-}\textsubscript{ovf\_diff}$ x) % 4|.
This simplifies to \lstinline|20 % 4|, which constant-folds to \lstinline|0|.

If we change the example to make the number of elements variable instead
of constant, we can see how canonicalization breaks down in the presence
of integer wraparound. Suppose the number of elements is given by a
variable \lstinline|k|. We would have:

\begin{lstlisting}[escapechar=\@]
// computed bounds
bounds(x, x @+\textsubscript{ovf}@ (sizeof(int) @*\textsubscript{unsigned}@ (size_t) k))
// expected bounds
bounds(x, x @+\textsubscript{ovf}@ (k @*\textsubscript{ovf}@ (signed_size_t) sizeof(int)))
\end{lstlisting}

After converting pointer arithmetic to integer arithmetic, we have:
\begin{lstlisting}[escapechar=\@]
// computed bounds
bounds(x, x @+\textsubscript{ovf}@ (4 @*\textsubscript{unsigned}@ (size_t) k))
// expected bounds
bounds(x, x @+\textsubscript{ovf}@ (k @*\textsubscript{ovf}@ 4))
\end{lstlisting}

Canonicalization of the upper bounds expressions produces:
\begin{lstlisting}[escapechar=\@]
// computed bounds
x @+\textsubscript{ovf}@ (4 @*\textsubscript{unsigned}@ (size_t) k))
// expected bounds
x @+\textsubscript{ovf}@ (4 @*\textsubscript{ovf}@ k)
\end{lstlisting}

The expressions are not identically syntactically, so bounds expression
checking fails. The additional side conditions that \lstinline|k >= 0 && k <= UINTPTR_MAX/4|
are needed to show that the computed upper bound implies the expected upper bound. More
general techniques from Chapter~\ref{chapter:simple-invariants} are needed to show that the context
bounds imply the expected bounds.

\subsection{Extending canonicalization to two's complement signed integer arithmetic}

In some widely-used C compilers, signed arithmetic implemented
as two's complement arithmetic is available under a compiler flag. In
this case, the expected arithmetic properties hold, which enables more
expressions to be canonicalized to the same form.

\section{Declarations}
\label{section:checking-declarations}

Declarations also need to be checked for consistency with their bounds
declarations. If the declaration is within a bundled block, the checking
is deferred to the end of the bundled block.

C distinguishes between declarations and definitions of variables. A
declaration declares the type and storage class for a variable. It may
or may not cause storage to be allocated for the variable. A definition
is a declaration of a variable that causes storage to be allocated for
the variable as well. Definitions may have initializers that initialize
the storage for the variable.

We first describe checking definitions, which is similar to checking
assignments. For a declaration, we assume that there is an ordered list of
\arrayptr\ variables and their optional initializers, and the
list of bounds declarations in the where clause for the declaration. The
list is ordered by the order of variable declarations.

First, the current context is computed before the declaration. Then, for
each variable \var{v} in the list,

\begin{itemize}
\item
  If \var{v} has an initializer, the current context is updated by
  traversing the assignment expressions in the initializer using the
  analysis from Section~\ref{section:checking-nested-assignment-expressions}. 
  The bounds for each individual assignment
  expression are recorded as well. Note that if \var{v} is a static
  variable, the assignment expressions must actually be constant
  expressions, so the context will not change.
\item
  If \var{v} has an \arrayptr\ type or an incomplete array
  type, the context is updated to record the new bounds for \var{v}:

  \begin{itemize}
  \item
    If \var{v} has no initializer, then

    \begin{itemize}
    \item
      If \var{v} is a static variable, then \var{v} will be
      initialized to 0. The context is updated to map \var{v} to
      \boundsany.
    \item
      If \var{v} is an automatic variable then \var{v} will have an
      indeterminate value. The context is updated to map v to
      \boundsunknown.
    \end{itemize}
  \item
    If \var{v} has an initializer, the initializer must have the form
    \var{e} or \lstinline|{| \var{e} \lstinline|}|. In both cases,

    \begin{itemize}
    \item
      If a temporary variable has been introduced for the value 
      of \var{e} and the temporary variable appears in the bounds for
      \var{e}, \var{v} is substituted for it.
    \item
      The context is updated to map v to the updated bounds.
    \end{itemize}
  \end{itemize}
\end{itemize}

The current context is then checked against the bounds declarations that
must be true after the declaration using the analysis in 
Section~\ref{section:checking-expression-statements}

Declarations that are not definitions are not checked, other than to
verify that all the declarations of a variable in a translation unit
have the same bounds declaration (or lack of a bounds declarations) for
the variable.

\section{Bundled declarations and statements}
\label{section:checking-bundled}

To check bundled declarations and statements, the current context is
determined before the bundled block. The current context is then updated
for each expression statement and declaration following the rules for
updating contexts in Sections~\ref{section:checking-expression-statements} and 
\ref{section:checking-declarations}. The analysis of 
Section~\ref{section:extent-definition}
is used to determine the expected bounds expression for each variable at
the end of the bundled block. The current context is checked against the
bounds declarations that must be true at the end of the block using the
analysis in Section~\ref{section:checking-expression-statements}

When an expression with \arrayptr\ type is dereferenced within
an expression statement in a bundled block, the current context before
the statement is used to determine the bounds for the expression. This
may cause an expression to have a different bounds than it normally
would have based on bounds declarations.

For example, suppose a pointer assignment is introduced into the middle
of the earlier example. The pointer assignment is highlighted in blue.
The bounds for \lstinline|parr| at that point in the program based on the
current context will be \lstinline|bounds(parr, parr + size)|.

\begin{lstlisting}[escapechar=\|]
int arr[DEFAULT_SIZE];
array_ptr<int> parr : count(len) = arr;
int plen = DEFAULT_SIZE;

f(int size) {
  if (size > DEFAULT_SIZE) {
    bundle {
      parr = malloc(sizeof(int) * size);
      |\sethlcolor{lightblue}\hl{*parr = 314;}|
      plen = size;
    }
  }
}
\end{lstlisting}

If the code were slightly rearranged, there would be a compile-time
error. The assignment to \code{plen} invalidates the bounds for
\code{parr} in the context at the point of the assignment.

\begin{lstlisting}[escapechar=\|]
f(int size) {
  if (size > DEFAULT_SIZE) {
    bundle {
      plen = size;
      |\sethlcolor{lightblue}\hl{*parr = 314;}| // error: parr has bounds of none.
      parr = malloc(sizeof(int) * size);
    }
  }
}
\end{lstlisting}

A function call within a bundled block require special treatment: the
bounds declarations for variables with static storage must be valid
before the call. The called function is assuming that the declared
bounds are valid. This means that the context before the function call
must imply that bounds declarations for variables in scope that have
static storage are valid.

\section{Function call arguments}
\label{section:checking-function-call-arguments}

Function call arguments also need to be checked for consistency with
expected bounds declarations. This is similar to checking of expression
statements with where clauses. For each call f(e\textsubscript{1}
\ldots{} e\textsubscript{n}) to a function f(x\textsubscript{1} \ldots{}
x\textsubscript{n}) that has bounds declarations for one or more
parameters,

\begin{itemize}
\item
  A statement of the form

  x\textsubscript{1} = e\textsubscript{1} \code{,} x\textsubscript{2} = 
  e\textsubscript{2} \code{,} \ldots{}. x\textsubscript{n} =
  e\textsubscript{n} where \var{conditions}\code{;}

  is constructed, where \var{conditions} contains all the bounds
  declarations on parameters. Parameters are renamed if necessary so
  that they have different names from variables in scope at the function
  call.
\item
  The context for the function call is constructed. The statement is
  checked in that context using the rules in 
  Section~\ref{section:checking-expression-statements}
\item
  A subtle point is that the order of evaluation for argument
  expressions in C is not defined (Section~\ref{section:avoiding-undefinedness}
  discusses order of
  evaluation issues in depth). A check is done also that the values of
  argument expressions used in checking the bounds declaration do not
  depend on the order of evaluation of arguments:

  \begin{itemize}
  \item
    The set of parameters that occur in bounds declarations for
    parameters is computed.
  \item
    Any argument expression corresponding to a parameter in this set
    cannot read a variable that is assigned to by another argument
    expression. If one does, the function call is rejected as not
    checking.
  \end{itemize}
\end{itemize}

 \section{Return statements}
 \label{section:checking-return-statements}

A return statement has the form \code{return} \var{e}, where \var{e}
is optional. If the special
variable \keyword{return\_value} occurs in the return bounds
for the function
\begin{itemize}
\item a new temporary is created and substituted for
\keyword{return\_value} in the return bounds.
\item  It is recorded that the new temporary and the result
of evaluating \var{e} are equal.
\end{itemize}
The bounds for \var{e} are computed.   It is then checked that
the bounds for \var{e} imply the (possibly updated) return
bounds, using  the rules in 
Section~\ref{section:checking-expression-statements}

Note that if the bounds of \var{e} involve a temporary,
the temporary does not occur in the (possibly updated) return bounds,
and no equality facts have been recorded involving the temporary,
the bounds of \var{e} cannot imply the return bounds are
valid.  There will be no connection between the temporary
and values used in the return bounds.

\section{Other statements}

There are a variety of other statements in C. These statements are built
from zero or more expressions, statements, and declarations:

\begin{itemize}
\item
  Labeled statements of the form \code{case}
  \var{constant-expression} \code{:} \var{statement},
  \code{default :} \var{statement}, and \var{identifier} :
  \var{statement}.
\item
  Selection statements of the form \code{if (}\var{expression}\code{)} 
  \var{statement} \code{else}
  \var{statement} and \code{switch (}\var{expression}\code{)}
  \var{statement}.
\item
  Iteration statements such as \code{while (}\var{expression}\code{)}
  \var{statement} and \code{for (}\var{declaration\textsubscript{opt}}
  \var{expression\textsubscript{opt}}\code{;} \var{expression\textsubscript{opt}} \code{;} 
   \var{expression\textsubscript{opt}}\code{)} \var{statement}.
\item
  Jump statements of the from \code{goto} \var{identifier},
  \code{continue}, and \code{break}.
\item
  Compound statements of the form \lstinline|{ ... }| where \lstinline|...|
  are zero or more declarations or statements.
\end{itemize}

The nested statements and declarations can be checked individually.

For the expressions used in the statements, the context is determined
before the evaluation of the expression. No way is provided for a direct
expression occurring in a statement to have new bounds declared for any
bounds in it. This means that the bounds declarations in the context
will be expected to be true after the evaluation of the expression too.

The rules in Section~\ref{section:checking-nested-assignment-expressions}
are used to determine the updated context after evaluation of the
expression. The rules in Section~\ref{section:checking-expression-statements}
are used to check that the updated
context implies the expected bounds declarations.

\section{Avoiding undefined expressions and undefined bounds}
\label{section:avoiding-undefinedness}

The order of evaluation of side-effects in subexpressions of an
expression is defined in C only in certain circumstances (these are
described in Section 6.5 and Annex C of \cite{ISO2011}). Otherwise, the order of
evaluation of side-effects is undefined. Although nested assignment
expressions help the brevity of programs, they lead to expressions whose
meaning or bounds are undefined. To avoid compromising the integrity of
bounds information, compilers must produce errors when they encounter
these expressions.

The meaning of an expression is undefined if:

\begin{\boundsunknown}
\item
  There are multiple assignments to the same variable within an
  expression where the order of evaluation of the assignments is
  undefined, or
\item
  There is an assignment to a variable that is also used by the
  expression, where the order of evaluation of the assignment and the
  use is undefined.
\end{\boundsunknown}

The following statements illustrate these problems:

\begin{lstlisting}
y = (x = 5) + (x = 6);
i = i++ + 1;
a[i++] = i;
\end{lstlisting}

In the first case, the value of the right-hand side expression is 11,
yet at the end of the expression, the value of x could be 5 or 6. In the
second case, there are two assignments to i and the order is undefined.
In the third case, it is not clear when i is read vs. when it is
modified.

Bounds checks can lead to a subtle version of the second problem: an
expression may have an assignment through a pointer that require a
bounds check. The bounds for the pointer expression may include a
variable that is modified in the expression, where the order of
evaluation of the assignment through the pointer and the variable
assignment is undefined. This means that the order of evaluation of the
bounds check and the variable assignment is undefined.

This example illustrates this problem:

\begin{lstlisting}
w = ...
where w : bounds(x, x + y);
int t = *w + (y = tmp);
\end{lstlisting}

The variable y is an integer variable that is a count of elements. It is
overwritten during the evaluation of an expression that dereferences w,
whose bounds include y.

We define these situations to be compile-time errors. Define an
ambiguous variable in an expression e as:

\begin{itemize}
\item
  A variable that has multiple assignments to it within e such that the
  order of evaluation of those assignments is undefined, or
\item
  A variable that has an assignment to it and a use of the variable such
  that the order of evaluation of the assignment and the use is
  undefined, or
\item
  A variable that has an assignment to it, where there is some
  subexpression *e1 of e where the variable appears in the bounds of e1
  and the order of evaluation of *e1 and the assignment to the variable
  is undefined.
\end{itemize}
It is a compile-time error for an expression to have an ambiguous
variable.
